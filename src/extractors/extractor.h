//
// Created by nispaur on 4/21/17.
//

#ifndef PBRT_V3_EXTRACTOR_H
#define PBRT_V3_EXTRACTOR_H

#include "extractors/pathoutput.h"
#include "extractors/pathio.h"
#include "reflection.h"
#include "geometry.h"
#include "film.h"
#include "pbrt.h"

namespace pbrt {
/**********************************************************************************************************************
 * Interface of Extractors :
 *      Extractors are object that register several internal states of the different rendering algorithms
 *
 *  Extractors are split into two kind of object :
 *      ExtractorXXX that manage the overall extracted data.
 *      ExtractorXXXTile that manage only the part of the extracted data generated by a rendering thread.
 *          Caution : when accumulating tiles on general manager, beware of race condition.
 *
 *  Extractors allow to generate several layers of film (FILM_EXTRACTOR):
 *      depth   --> each pixel contains the screen-space depth.
 *      albedo  --> each pixel contains the albedo of the surfaces seen.
 *      normal  --> each pixel contains the world-space normal.
 *
 *  Extractors allow to dump all the light paths on disk for off-line analysis (PATH_EXTRACTOR).
 *      CAUTION : GENERATED FILES MIGHT BE HUGE (SEVERAL TERABYTES)
 *      CAUTION : THIS IS A VERY EXPERIMENTAL STUFF NOT YET FULLY FONCTIONNAL
 *      Extracted paths may be selected according to Heckbert regular expressions
 *      CAUTION : Works only (with bugs) for Sampler Integrators and Bidirectionnal Path Tracing
 *
 *  Extractors can also use custom format for extracting informations (CUSTOM_EXTRACTOR)
 *      Statistics : Allow to extract, per pixel, statistical information about the luminance estimation :
 *          mean, variance, error, number of samples ...
 *
 * TODO (s)
 *  ProfilePhase p(Prof::ExtractorReport);
 *      Check consistency and presence
 *  Memory management
 *      Check memory leaks, remove unneeded dynamic allocation, use ARENA allocator where efficient
 *  Improve performances
 *      Rewrite the interface of extractors to remove heavy polymorphism.
 *
 *********************************************************************************************************************/
// Extractor types
enum ExtractorType : unsigned int {
    FILM_EXTRACTOR,
    PATH_EXTRACTOR,
    CUSTOM_EXTRACTOR, // TODO : find a better identifier
    EXTRACTOR_SET,
    NUM_EXTRACTOR_TYPE
};

// Definition of extractor interface : starting work on Sept. 13rd
class Extractor {
public:
    explicit Extractor(ExtractorType t) : type(t) {}
    Extractor(const Extractor &) = delete;
    virtual ~Extractor() = default;

    // type of extractor
    ExtractorType Type() const { return type; }

    // Tiling stuff
    virtual std::unique_ptr<Extractor> BeginTile(const Bounds2i &tileBound) const = 0;
    // End tile get a tiledExtractor as parameter and merge it with the current full extractor.
    // Tiled extractors might use this method with a null parameter to finalize the tile
    virtual void EndTile(std::unique_ptr<Extractor> sourceTiledExtractor = nullptr) const = 0;

    // Pixel stuff
    virtual void BeginPixel(const Point2i &pix) {}
    virtual void EndPixel() {}

    // Sample stuff
    virtual void BeginSample(const Point2f &p) {}
    virtual void EndSample(const Spectrum &throughput, float weight = 1.f) {}

    // Path (or Sample) stuff. May be simplified ?
    virtual void BeginPath(const Point2f &p) {}
    // incremental building of a path, usefull for SamplerIntegrators
    /* TODO, see how to generate complete path vertices (like bdpt one) for path-tracing like integrators */
    virtual void AddCameraVertex(Point3f o /* TODO : is this sufficient ? */) {}
    virtual void AddLightVertex(/* TODO : find how to generate this kind of path vertex from a sampler integrator */) {}
    virtual void AddPathVertex(const SurfaceInteraction &isect, const std::tuple<Spectrum, Float, Float, BxDFType> &bsdf) {}
    // direct building of a path, usefull for bidirectionnal integrators
    virtual void AddPathVertices(const Vertex *lightVertrices, const Vertex *cameraVertrices, int s, int t) {}
    virtual void EndPath(const Spectrum &throughput, float weight = 1.f) {}

    // General stuff
    // Are they really necessary ? Constructors might do the job.
    // If necessary, what are the parameters of these ???
    virtual void Initialize(const Bounds3f & worldBound) {}
    virtual void Flush(float splatScale = 1.f) = 0;

private:
    ExtractorType type;
};

class ExtractorSet : public Extractor {
public:
    ExtractorSet() : Extractor(EXTRACTOR_SET) {}
    ExtractorSet (const ExtractorSet &e) = delete;

    ~ExtractorSet() = default;

    std::unique_ptr<Extractor> BeginTile(const Bounds2i &tileBound) const;
    void EndTile(std::unique_ptr<Extractor> sourceTiledExtractor) const;

    void BeginPixel(const Point2i &pix);
    void EndPixel();

    void BeginSample(const Point2f &p);
    void EndSample(const Spectrum &throughput, float weight = 1.f);

    void BeginPath(const Point2f &p);
    void AddCameraVertex(Point3f o);
    void AddLightVertex();
    void AddPathVertex(const SurfaceInteraction &isect, const std::tuple<Spectrum, Float, Float, BxDFType> &bsdf);
    void AddPathVertices(const Vertex *lightVertrices, const Vertex *cameraVertrices, int s, int t);
    void EndPath(const Spectrum &throughput, float weight = 1.f);

    void Initialize(const Bounds3f & worldBound);
    void Flush(float splatScale);

    void AddExtractor(std::unique_ptr<Extractor> e) {
        extractors.emplace( std::make_pair(e->Type(), std::move(e)) );
    }

private:
    std::multimap< ExtractorType, std::unique_ptr<Extractor> > extractors;
};


class ExtractorNormal : public Extractor {
public:
    explicit ExtractorNormal(Film *f) : Extractor(FILM_EXTRACTOR), film(f) {}
    ExtractorNormal (const ExtractorSet &e) = delete;
    ~ExtractorNormal() = default;

    // Extractor interface implementation
    // Tiling stuff
    std::unique_ptr<Extractor> BeginTile(const Bounds2i &tileBound) const;
    void EndTile(std::unique_ptr<Extractor> sourceTiledExtractor) const;

    // General stuff
    void Initialize(const Bounds3f & worldBound);
    void Flush(float splatScale);

private:
    std::unique_ptr<Film> film;
};

class ExtractorNormalTile : public Extractor {
public:
    ExtractorNormalTile(Film *f, const Bounds2i &tileBound);
    ExtractorNormalTile (const ExtractorNormalTile &e) = delete;
    ~ExtractorNormalTile() = default;

    std::unique_ptr<Extractor> BeginTile(const Bounds2i &tileBound) const;
    void EndTile(std::unique_ptr<Extractor> sourceTiledExtractor) const;

    // no need for pixel nor sample stuff
    void BeginPath(const Point2f &p);
    void AddCameraVertex(Point3f o);
    // no need for light vertex
    void AddPathVertex(const SurfaceInteraction &isect, const std::tuple<Spectrum, Float, Float, BxDFType> &bsdf);
    void AddPathVertices(const Vertex *lightVertrices, const Vertex *cameraVertrices, int s, int t);
    void EndPath(const Spectrum &throughput, float weight = 1.f);

    void Initialize(const Bounds3f & worldBound);
    void Flush(float splatScale);

    std::unique_ptr<FilmTile> GetTile() {
        return std::move(film);
    }
private:
    // output of the extraction
    std::unique_ptr<FilmTile> film;
    // State for extraction
    Point2f samplePos;
    Normal3f n;
    bool first;
    bool valid_path;
};


// TODO : generalize depth extractor for each kind of Camera
class ExtractorDepth : public Extractor {
public:
    explicit ExtractorDepth(Film *f, float zn=1e-2f, float zf=1000.f);
    ExtractorDepth (const ExtractorSet &e) = delete;
    ~ExtractorDepth() = default;

    std::unique_ptr<Extractor> BeginTile(const Bounds2i &tileBound) const;
    void EndTile(std::unique_ptr<Extractor> sourceTiledExtractor) const;

    void Initialize(const Bounds3f & worldBound);
    void Flush(float splatScale);

private:
    std::unique_ptr<Film> film;
    const Float znear;
    const Float zfar;

};

class ExtractorDepthTile : public Extractor {
public:
    ExtractorDepthTile(Film *f, const Bounds2i &tileBound, float zn, float zf);
    ExtractorDepthTile (const ExtractorNormalTile &e) = delete;
    ~ExtractorDepthTile() = default;

    std::unique_ptr<Extractor> BeginTile(const Bounds2i &tileBound) const;
    void EndTile(std::unique_ptr<Extractor> sourceTiledExtractor) const;


    // no need for pixel nor sample stuff
    void BeginPath(const Point2f &p);
    void AddCameraVertex(Point3f o);
    // no need to light vertex
    void AddPathVertex(const SurfaceInteraction &isect, const std::tuple<Spectrum, Float, Float, BxDFType> &bsdf);
    void AddPathVertices(const Vertex *lightVertrices, const Vertex *cameraVertrices, int s, int t);
    void EndPath(const Spectrum &throughput, float weight = 1.f);


    void Initialize(const Bounds3f & worldBound);
    void Flush(float splatScale);

    std::unique_ptr<FilmTile> GetTile() {
        return std::move(film);
    }
private:
    float ConvertDepth(float z){
        return ( (z <= znear) ? 0.f : zscale * (1.0f - znear/z) );
    }
    // output of the extraction
    std::unique_ptr<FilmTile> film;
    // State for extraction
    Point2f samplePos;

    const Float znear;
    const Float zfar;
    Float zscale;

    Point3f rayorigin;
    Float realdepth;

    bool first;
    bool valid_path;
};


class ExtractorAlbedo : public Extractor {

public:
    ExtractorAlbedo(Film *f, BxDFType bxdfType, bool integrateAlbedo, int nbSamples);
    ExtractorAlbedo (const ExtractorSet &e) = delete;
    ~ExtractorAlbedo() = default;

    std::unique_ptr<Extractor> BeginTile(const Bounds2i &tileBound) const;
    void EndTile(std::unique_ptr<Extractor> sourceTiledExtractor) const;

    void Initialize(const Bounds3f & worldBound);
    void Flush(float splatScale);

private:
    std::unique_ptr<Film> film;
    BxDFType bxdf_type;
    bool integrate_albedo;
    int nb_samples;

};

// Tile extractor
class ExtractorAlbedoTile : public Extractor {
public:
    ExtractorAlbedoTile(Film *f, const Bounds2i &tileBound, BxDFType bxdfType, bool integrateAlbedo, int nbSamples);
    ExtractorAlbedoTile (const ExtractorNormalTile &e) = delete;
    ~ExtractorAlbedoTile() = default;

    std::unique_ptr<Extractor> BeginTile(const Bounds2i &tileBound) const;
    void EndTile(std::unique_ptr<Extractor> sourceTiledExtractor) const;


    // no need for pixel nor sample stuff
    void BeginPath(const Point2f &p);
    void AddCameraVertex(Point3f o);
    // no need to light vertex
    void AddPathVertices(const Vertex *lightVertrices, const Vertex *cameraVertrices, int s, int t);
    void AddPathVertex(const SurfaceInteraction &isect, const std::tuple<Spectrum, Float, Float, BxDFType> &bsdf);
    void EndPath(const Spectrum &throughput, float weight = 1.f);


    void Initialize(const Bounds3f &worldBound);
    void Flush(float splatScale);

    std::unique_ptr<FilmTile> GetTile() {
        return std::move(film);
    }
private:
    Spectrum computeAlbedo(BSDF *bsdf, const Vector3f &dir);

    std::unique_ptr<FilmTile> film;

    // State for extraction
    Point2f samplePos;

    BxDFType bxdf_type;
    bool integrate_albedo;
    int nb_samples;
    Spectrum rho;
    std::vector<Point2f> wi;
    std::vector<Point2f> wo;

    bool first;
    bool valid_path;
};

// API Methods
Extractor *CreateNormalExtractor(const ParamSet &params, std::shared_ptr<const Camera> camera);

Extractor *CreateDepthExtractor(const ParamSet &params, std::shared_ptr<const Camera> camera);

Extractor *CreateAlbedoExtractor(const ParamSet &params, std::shared_ptr<const Camera> camera);

Extractor *CreateStatisticsExtractor(const ParamSet &params, std::shared_ptr<const Camera> camera);



}


#endif //PBRT_V3_EXTRACTOR_H
